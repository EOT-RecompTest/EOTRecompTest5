uint32_t LoadXexModuleUnified(const std::filesystem::path& path, bool strictMode = true) {
    auto data = LoadFile(path);
    if (data.empty()) {
        spdlog::error("‚ùå Failed to load .xex from {}", path.string());
        std::exit(1);
    }

    const auto* header = reinterpret_cast<const Xex2Header*>(data.data());
    const auto* security = reinterpret_cast<const Xex2SecurityInfo*>(data.data() + header->securityOffset);
    const auto* fileFormat = reinterpret_cast<const Xex2OptFileFormatInfo*>(
        getOptHeaderPtr(data.data(), XEX_HEADER_FILE_FORMAT_INFO));
    const auto* entryPtr = reinterpret_cast<const uint32_t*>(getOptHeaderPtr(data.data(), XEX_HEADER_ENTRY_POINT));

    uint32_t entry = entryPtr ? *entryPtr : 0;
    ByteSwapInplace(entry);
    spdlog::info("üöÄ XEX entry point at 0x{:08X}", entry);

    std::vector<std::pair<uint32_t, uint32_t>> loadedRanges;
    bool usedSectionLoader = false;

    // Section loader
    const uint8_t* sectionTableData = reinterpret_cast<const uint8_t*>(
        getOptHeaderPtr(data.data(), XEX_HEADER_SECTION_TABLE));
    if (sectionTableData) {
        uint32_t dwordCount = reinterpret_cast<const uint32_t*>(sectionTableData)[0];
        ByteSwapInplace(dwordCount);

        const size_t sectionCount = (dwordCount - 1) / 3;
        const auto* sections = reinterpret_cast<const XexSectionTableEntry*>(sectionTableData + 4);
        const size_t maxValid = (data.data() + data.size() - (sectionTableData + 4)) / sizeof(XexSectionTableEntry);

        if (sectionCount <= maxValid && sectionCount <= 512) {
            spdlog::info("üìñ Parsing {} XEX sections", sectionCount);
            for (size_t i = 0; i < sectionCount; ++i) {
                const auto& s = sections[i];
                const uint32_t flags = s.info & 0xF0000000;
                const uint32_t size  = s.info & SECTION_SIZE_MASK;
                const uint32_t vaddr = s.virtualAddr;
                const uint32_t raw   = s.rawAddr;

                if (size == 0 || vaddr < kMinVirtualAddr || vaddr >= kMaxVirtualAddr) {
                    spdlog::warn("‚ö†Ô∏è Skipping suspicious section {}: vaddr=0x{:08X}, size=0x{:X}", i, vaddr, size);
                    continue;
                }

                uint8_t* dest = reinterpret_cast<uint8_t*>(g_memory.Translate(vaddr));
                if (!dest) {
                    spdlog::error("‚ùå Failed to translate section {} vaddr=0x{:08X}", i, vaddr);
                    continue;
                }

                if (flags & XEX_SECTION_NO_LOAD || raw == 0) {
                    std::memset(dest, 0, size);
                    spdlog::info("üßº Zeroed .bss section {} at 0x{:08X} ({} bytes)", i, vaddr, size);
                } else {
                    if (raw + size > data.size()) {
                        spdlog::error("‚ùå Section {} raw data out of bounds", i);
                        continue;
                    }
                    std::memcpy(dest, data.data() + raw, size);
                    spdlog::info("üì¶ Copied section {} to 0x{:08X} ({} bytes)", i, vaddr, size);
                }

                loadedRanges.emplace_back(vaddr, vaddr + size);
            }

            usedSectionLoader = true;
        } else {
            spdlog::warn("‚ö†Ô∏è Section table malformed: {} sections", sectionCount);
        }
    }

    // Fallback loader if needed
    bool entryCovered = std::any_of(loadedRanges.begin(), loadedRanges.end(), [&](const auto& r) {
        return entry >= r.first && entry < r.second;
    });

    if (!usedSectionLoader || !entryCovered) {
        spdlog::warn("‚ö†Ô∏è Falling back to flat loader");
        const uint32_t rawLoadAddress = static_cast<uint32_t>(security->loadAddress);
        uint8_t* dest = reinterpret_cast<uint8_t*>(g_memory.Translate(rawLoadAddress));
        if (!dest) {
            spdlog::error("‚ùå Failed to translate flat load address 0x{:08X}", rawLoadAddress);
            std::exit(1);
        }

        const uint8_t* src = data.data() + header->headerSize;
        if (fileFormat->compressionType == XEX_COMPRESSION_NONE) {
            std::memcpy(dest, src, security->imageSize);
            spdlog::info("üì¶ Flat copy to 0x{:08X} ({} bytes)", rawLoadAddress, static_cast<uint32_t>(security->imageSize));
        } else if (fileFormat->compressionType == XEX_COMPRESSION_BASIC) {
            const auto* blocks = reinterpret_cast<const Xex2FileBasicCompressionBlock*>(fileFormat + 1);
            size_t numBlocks = (fileFormat->infoSize / sizeof(Xex2FileBasicCompressionInfo)) - 1;

            for (size_t i = 0; i < numBlocks; ++i) {
                std::memcpy(dest, src, blocks[i].dataSize);
                dest += blocks[i].dataSize;
                src += blocks[i].dataSize;

                std::memset(dest, 0, blocks[i].zeroSize);
                dest += blocks[i].zeroSize;
            }

            spdlog::info("üì¶ Decompressed {} blocks to 0x{:08X}", numBlocks, rawLoadAddress);
        } else {
            spdlog::error("‚ùå Unknown compression type: {}", static_cast<uint32_t>(fileFormat->compressionType));
            std::exit(1);
        }
    }

    // Load XDBF resource if present
    const auto* res = reinterpret_cast<const Xex2ResourceInfo*>(
        getOptHeaderPtr(data.data(), XEX_HEADER_RESOURCE_INFO));
    if (res) {
        const uint32_t offset = static_cast<uint32_t>(res->offset);
        const uint32_t size = static_cast<uint32_t>(res->sizeOfData);

        void* xdbfPtr = g_memory.Translate(offset);
        if (xdbfPtr) {
            g_xdbfWrapper = XDBFWrapper(static_cast<uint8_t*>(xdbfPtr), size);
            spdlog::info("üîñ XDBF loaded at 0x{:08X} ({} bytes)", offset, size);
        } else {
            spdlog::warn("‚ö†Ô∏è Failed to translate XDBF offset 0x{:08X}", offset);
        }
    } else {
        spdlog::warn("‚ö†Ô∏è No XEX_HEADER_RESOURCE_INFO found");
    }

    return entry;
}